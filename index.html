// Live raised calc (incoming SOL) with caching (best effort)
    // ======================
    const CACHE_KEY = "memex_presale_cache_v5";

    function loadCache(){
      try{
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return { totalLamports: 0, seen: {}, lastUpdated: 0 };
        const obj = JSON.parse(raw);
        if (!obj || typeof obj.totalLamports !== "number") throw new Error("bad");
        obj.seen = obj.seen || {};
        return obj;
      }catch{
        return { totalLamports: 0, seen: {}, lastUpdated: 0 };
      }
    }
    function saveCache(c){ localStorage.setItem(CACHE_KEY, JSON.stringify(c)); }

    async function fetchNewIncomingLamports(treasuryPk, cache){
      const limit = CONFIG.SIG_PAGE_SIZE;
      let before = undefined;
      let processed = 0;

      while (processed < CONFIG.MAX_NEW_SIGS_PER_REFRESH) {
        const sigs = await withRpcFailover(() =>
          connection.getSignaturesForAddress(treasuryPk, { limit, before }, "confirmed")
        );
        if (!sigs || sigs.length === 0) break;

        for (const s of sigs) {
          const sig = s.signature;
          if (cache.seen[sig]) return;

          cache.seen[sig] = 1;
          processed++;

          const tx = await withRpcFailover(() =>
            connection.getTransaction(sig, { commitment:"confirmed", maxSupportedTransactionVersion: 0 })
          );
          if (!tx || !tx.meta) continue;

          const msg = tx.transaction.message;
          const keys = (msg.getAccountKeys && msg.getAccountKeys().staticAccountKeys)
            ? msg.getAccountKeys().staticAccountKeys
            : msg.accountKeys;

          const keyStrings = keys.map(k => k.toString());
          const idx = keyStrings.indexOf(treasuryPk.toString());
          if (idx === -1) continue;

          const pre = tx.meta.preBalances?.[idx] ?? 0;
          const post = tx.meta.postBalances?.[idx] ?? 0;
          const delta = post - pre;

          if (delta > 0) cache.totalLamports += delta;

          if (processed >= CONFIG.MAX_NEW_SIGS_PER_REFRESH) break;
        }

        before = sigs[sigs.length - 1].signature;
        if (sigs.length < limit) break;
      }
    }

    let refreshLock = false;

    async function refreshRaised(showStatus){
      if (refreshLock) return;
      refreshLock = true;

      const cache = loadCache();
      const treasuryPk = new PublicKey(CONFIG.TREASURY_ADDRESS);

      try{
        if (showStatus) setStatus("Refreshing on-chain progress…");
        await fetchNewIncomingLamports(treasuryPk, cache);

        cache.lastUpdated = Date.now();
        saveCache(cache);

        const raisedSol = cache.totalLamports / LAMPORTS_PER_SOL;
        updateAllUI(raisedSol);

        if (showStatus) setStatus("Updated ✅");
      }catch(e){
        if (showStatus) setStatus("Refresh unavailable (RPC). Try later.");
      }finally{
        refreshLock = false;
      }
    }

    btnRefresh.addEventListener("click", () => refreshRaised(true));

    // init
    updateAllUI(0);
    refreshRaised(false);
    setInterval(() => refreshRaised(false), CONFIG.AUTO_REFRESH_MS);
    setInterval(updateCountdownUI, 1000);
  </script>
</body>
</html>
