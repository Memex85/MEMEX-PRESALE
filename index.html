    setWalletInfo("Connected: " + shortAddr(walletPublicKey.toString()));
        setStatus("Wallet connected ✅");
      }catch{
        setStatus("Connect cancelled.");
      }
    }

    async function disconnectWallet(){
      try{ if (provider) await provider.disconnect(); }catch{}
      walletPublicKey = null;
      btnDisconnect.disabled = true;
      setWalletInfo("");
      setStatus("Disconnected.");
    }

    btnConnect.addEventListener("click", connectWallet);
    btnDisconnect.addEventListener("click", disconnectWallet);

    // MAX uses RPC best-effort (doesn't affect SEND)
    btnMax.addEventListener("click", async () => {
      if (!walletPublicKey) { setStatus("Connect wallet first."); return; }
      try{
        const bal = await withRpcFailover(() => connection.getBalance(walletPublicKey, "confirmed"));
        const sol = bal / LAMPORTS_PER_SOL;
        const max = Math.max(0, sol - 0.00005);
        amountEl.value = max.toFixed(4);
        setStatus("Max filled (fee reserved).");
      }catch{
        setStatus("MAX unavailable (RPC issue). Enter amount manually.");
      }
    });

    // ✅ SEND uses Phantom directly (no RPC blockhash needed)
    btnSend.addEventListener("click", async () => {
      provider = getProvider();
      if (!provider) { setStatus("Phantom not found. Open in Phantom Browser."); return; }
      if (!walletPublicKey) { setStatus("Connect your wallet first."); return; }

      const amt = parseSolInput(amountEl.value);
      if (!amt || amt <= 0) { setStatus("Enter a valid SOL amount."); return; }
      if (amt < CONFIG.MIN_SOL) { setStatus("Min buy is " + CONFIG.MIN_SOL + " SOL."); return; }

      try{
        const toPubkey = new PublicKey(CONFIG.TREASURY_ADDRESS);
        const lamports = Math.round(amt * LAMPORTS_PER_SOL);

        const tx = new Transaction().add(
          SystemProgram.transfer({
            fromPubkey: walletPublicKey,
            toPubkey,
            lamports
          })
        );

        // IMPORTANT:
        // Do NOT set recentBlockhash here.
        // Phantom will populate feePayer + recentBlockhash internally.
        tx.feePayer = walletPublicKey;

        setStatus("Approve in Phantom…");

        const res = await provider.signAndSendTransaction(tx);
        const sig = res?.signature || res;

        setStatus("Sent ✅ TX: " + sig + " (save this)");

        // Optional: best-effort confirm (won't block)
        try{
          await withRpcFailover(() => connection.confirmTransaction(sig, "confirmed"));
          setStatus("Confirmed ✅ TX: " + sig + " (save this)");
        }catch{
          // keep sent message; confirmation can be checked in Phantom
        }

        // Optional: best-effort refresh progress
        try{ await refreshRaised(false); }catch{}
      }catch(e){
        const msg = String(e?.message || e || "");
        if (msg.toLowerCase().includes("user rejected") || msg.toLowerCase().includes("rejected")) {
          setStatus("Transaction cancelled.");
          return;
        }
        setStatus("Send error: " + (e?.message || "unknown"));
      }
    });

    // auto-connect if trusted
    (async () => {
      provider = getProvider();
      if (provider && provider.isPhantom) {
        try{
          const resp = await provider.connect({ onlyIfTrusted: true });
          walletPublicKey = resp.publicKey;
          btnDisconnect.disabled = false;
          setWalletInfo("Connected: " + shortAddr(walletPublicKey.toString()));
        }catch{}
      }
    })();

    // ======================
    // Phase / Progress Logic
    // ======================
    const PHASE3_START_KEY = "memex_phase3_start_ms_v1";

    function getPhase(raisedSol){
      if (raisedSol < CONFIG.P1_CAP) {
        return { n:1, name:"Phase 1", rate:"1 SOL = 8,000,000 MEMEX", cap:CONFIG.P1_CAP, base:0, info:"0–10 SOL" };
      }
      if (raisedSol < (CONFIG.P1_CAP + CONFIG.P2_CAP)) {
        return { n:2, name:"Phase 2", rate:"1 SOL = 6,000,000 MEMEX", cap:CONFIG.P2_CAP, base:CONFIG.P1_CAP, info:"10–30 SOL" };
      }
      return { n:3, name:"Phase 3", rate:"1 SOL = 4,000,000 MEMEX", cap:CONFIG.P3_CAP, base:(CONFIG.P1_CAP + CONFIG.P2_CAP), info:"30–180 SOL • 7d max" };
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function ensurePhase3Start(raisedSol){
      if (raisedSol < (CONFIG.P1_CAP + CONFIG.P2_CAP)) return;
      const existing = localStorage.getItem(PHASE3_START_KEY);
      if (existing) return;
      localStorage.setItem(PHASE3_START_KEY, String(Date.now()));
    }

    function formatCountdown(ms){
      ms = Math.max(0, ms);
      const totalSec = Math.floor(ms / 1000);
      const d = Math.floor(totalSec / 86400);
      const h = Math.floor((totalSec % 86400) / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      return `${d}d ${String(h).padStart(2,"0")}h ${String(m).padStart(2,"0")}m ${String(s).padStart(2,"0")}s`;
    }

    function updateCountdownUI(){
      const startRaw = localStorage.getItem(PHASE3_START_KEY);
      if (!startRaw) { phase3TimerBox.style.display = "none"; return; }
      const start = Number(startRaw);
      if (!start || !isFinite(start)) { phase3TimerBox.style.display = "none"; return; }

      const end = start + CONFIG.PHASE3_DURATION_MS;
      const left = end - Date.now();
      phase3TimerBox.style.display = "flex";
      phase3CountdownEl.textContent = formatCountdown(left);
    }

    function updateAllUI(raisedSol){
      raisedTotalEl.textContent = Number(raisedSol).toFixed(2);

      const ph = getPhase(raisedSol);
      phaseNameEl.textContent = ph.name;
      phaseRateEl.textContent = ph.rate;
      phaseInfoEl.textContent = ph.info;

      const inPhase = clamp(raisedSol - ph.base, 0, ph.cap);
      const pct = ph.cap > 0 ? Math.floor((inPhase / ph.cap) * 100) : 0;

      progressTitleEl.textContent = `${ph.name} Progress`;
      progressLeftEl.textContent = inPhase.toFixed(2);
      progressCapEl.textContent = ph.cap;
      progressPctEl.textContent = pct;

      barFill.style.width = pct + "%";

      ensurePhase3Start(raisedSol);
      updateCountdownUI();
    }

    // ======================
    // Live raised calc (incoming SOL) with caching (best effort)
    // ======================
    const CACHE_KEY = "memex_presale_cache_v5";

    function loadCache(){
      try{
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return { totalLamports: 0, seen: {}, lastUpdated: 0 };
        const obj = JSON.parse(raw);
        if (!obj || typeof obj.totalLamports !== "number") throw new Error("bad");
        obj.seen = obj.seen || {};
        return obj;
      }catch{
        return { totalLamports: 0, seen: {}, lastUpdated: 0 };
      }
    }
    function saveCache(c){ localStorage.setItem(CACHE_KEY, JSON.stringify(c)); }

    async function fetchNewIncomingLamports(treasuryPk, cache){
      const limit = CONFIG.SIG_PAGE_SIZE;
      let before = undefined;
      let processed = 0;

      while (processed < CONFIG.MAX_NEW_SIGS_PER_REFRESH) {
        const sigs = await withRpcFailover(() =>
          connection.getSignaturesForAddress(treasuryPk, { limit, before }, "confirmed")
        );
        if (!sigs || sigs.length === 0) break;

        for (const s of sigs) {
          const sig = s.signature;
          if (cache.seen[sig]) return;

          cache.seen[sig] = 1;
          processed++;

          const tx = await withRpcFailover(() =>
            connection.getTransaction(sig, { commitment:"confirmed", maxSupportedTransactionVersion: 0 })
          );
          if (!tx || !tx.meta) continue;

          const msg = tx.transaction.message;
          const keys = (msg.getAccountKeys && msg.getAccountKeys().staticAccountKeys)
            ? msg.getAccountKeys().staticAccountKeys
            : msg.accountKeys;

          const keyStrings = keys.map(k => k.toString());
          const idx = keyStrings.indexOf(treasuryPk.toString());
          if (idx === -1) continue;

          const pre = tx.meta.preBalances?.[idx] ?? 0;
          const post = tx.meta.postBalances?.[idx] ?? 0;
          const delta = post - pre;

          if (delta > 0) cache.totalLamports += delta;

          if (processed >= CONFIG.MAX_NEW_SIGS_PER_REFRESH) break;
        }

        before = sigs[sigs.length - 1].signature;
        if (sigs.length < limit) break;
      }
    }

    let refreshLock = false;

    async function refreshRaised(showStatus){
      if (refreshLock) return;
      refreshLock = true;

      const cache = loadCache();
      const treasuryPk = new PublicKey(CONFIG.TREASURY_ADDRESS);

      try{
        if (showStatus) setStatus("Refreshing on-chain progress…");
        await fetchNewIncomingLamports(treasuryPk, cache);

        cache.lastUpdated = Date.now();
        saveCache(cache);

        const raisedSol = cache.totalLamports / LAMPORTS_PER_SOL;
        updateAllUI(raisedSol);

        if (showStatus) setStatus("Updated ✅");
      }catch(e){
        if (showStatus) setStatus("Refresh unavailable (RPC). Try later.");
      }finally{
        refreshLock = false;
      }
    }

    btnRefresh.addEventListener("click", () => refreshRaised(true));

    // init
    updateAllUI(0);
    refreshRaised(false);
    setInterval(() => refreshRaised(false), CONFIG.AUTO_REFRESH_MS);
    setInterval(updateCountdownUI, 1000);
  </scrip
